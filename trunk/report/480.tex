\documentclass[12pt]{report}
\usepackage{graphicx}
\usepackage{algorithm}
\usepackage{algorithmic}
\usepackage{keystroke}
\usepackage{pdfcomment}
\usepackage{gensymb}

\newcommand{\note}[1]{\raisebox{0pt}[0pt][0pt]{\pdfcomment[open=true]{#1}}}

% [dme] reordered these document definitions - title, author, date -
% if they sit here, they can potentially use the macros you include
% from packages
\title{Avoiding the Dark Side}
\author{
        Leslie Chisholm \\
                Department of Computer Science\\
}
\date{\today}

\begin{document}
\maketitle

\begin{abstract}
This is the paper's abstract \ldots
\end{abstract}

\tableofcontents
\listoffigures\
\listofalgorithms
\chapter{Introduction}
The city of Dunedin is well known for being a dark and cold city because of the hills surrounding the centre of the city that shade large areas in the winter months. This project set out to discover the amount of sunlight Dunedin receives and present the data in a user friendly manner.

\section{Goals}
The goals of this project were research and implement a sunlight projection model for the city of Dunedin. There are two parts; an interactive three-dimensional display to show point in time distribution of sunlight over Dunedin and a data aggregator to augment the display with computed measures of sunlight coverage over time ranges.

\section{Chapter outline}
Chapter two focuses on how physical data was gathered from the environment, the methods used to convert them into a representation usable for the project and the accuracy that was obtained in these measurements. Chapter three looks at the interactive three-dimensional viewer built to display the distribution of sunlight over Dunedin in real-time and its implementation using OpenGL and JOGL. Chapter four is about the data aggregator, which accurately calculates the amount of sunlight an area receives, how the data it calculates can be explored and the results generated.

\section{Background Information}
\subsection{OpenGL and JOGL} 
To create the viewer and allow it to be used in an interactive method the Java OpenGL (JOGL)\cite{JOGL} libraries are used. JOGL is a wrapper library that exports the OpenGL application programming interface (API) to the Java programming language. OpenGL or Open Graphics Library is a cross platform API for writing applications that use two and three dimensional computer graphics. The project uses version 2.0 of the OpenGL libraries for access to programmable shaders and buffer objects and will be able to run on any graphics hardware that supports OpenGL 2.0.

\note{Does `Background' normally sit in the introduction chapter? In a PhD thesis it would usually be chapter two. The problem with having it here is that the chapter outline comes after it. In most theses I've seen (these are not 480 project reports though) only the introduction text would come before the chapter outline. Hmm ok I've moved it to be after the chapter outline. I don't think a whole chapter could be taken up with background information}


\chapter{Physical Data}
A digital elevation model of Dunedin and a mathematical model of the sun's position make up the two main physical data sets required to show how shadows are cast.

\section{Elevation Data}
\begin{figure}
\includegraphichs[scale=0.4]{height.png}
\caption{A Height Map generated from the data with low points dark and high points bright}
\label{elevation}
\end{figure}

The height data for Dunedin was collected from the surveying department of the University of Otago. The data contains a map with a width of 1237 points and a height of 881 points and covers most of general Dunedin from South Taieri to the top of Pine Hill. The data is encoded as a 1237x881 text file of decimal pointed numbers that represent the height above sea level in metres of that point. The resolution of the data is 20 metres between points. 

From \ref{elevation} it can be seen that there are areas that are less accurate where the data is approximated and smoothed out, such as the hills west of the Leith Valley and around Cape Saunders. The definition between what is in water and what is not also gets complicated when dealing with areas of reclaimed land like South Dunedin and the height data does not contain a fixed value for the water height.

\begin{figure}
\includegraphics[scale=0.4]{terrain.png}
\caption{Water texture}
\label{overlaytexture}
\end{figure}
To work around the lack of definition of what is at water level and what is not, an image was generated (see \ref{overlaytexture}) with the areas of water coloured a strong blue (RGB 0,0,255). The image is overlayed on the height data map when being used in the viewer with a 1:1 mapping of height points to image pixels to show what areas of land are in water. The areas of the height data that fall in the water are clamped to a height of 0.1 because the shape and depth of the ocean floor is of no use to the project.


\subsection{Accuracy}
To test the accuracy of the height data a global positioning system (GPS) was to be used to check the accuracy of the height points however this turned out to be infeasible because the accuracy of the GPS's height data was far lower than expected and to inaccurate to be included in the project. A GPS is rated to be accurate to approximately +/- 15 metres 95\% of the time\cite{gpsaltitude}. The inaccuracies were observed when standing at sea level with a GPS and getting results approximately 10 metres higher than the current position.

The best way to confirm the accuracy of the height data would be to compare it to other geographical data sources. Before going to the surveying department for the height information other sources were tried. The Shuttle Radio Topography Mission (SRTM)\cite{srtm} was a near-global scale project by NASA to generate topographical maps and includes all of New Zealand at a resolution of 30 metres. A old version of ARC GIS was provided by Geoff Wyvill containing topographical information about New Zealand, unfortunately the software to read the topographical maps was quite old and could not be run on any of the operating systems there was access to in the department.

\subsection{Future Work}
Unfortunately time constraints meant that there was not enough time to explore these methods of collecting height data and compare them to the height data.
 Given more time these data sources could be thoroughly explored and a larger collection of geographical data collected and utilised within the project, allowing the user to examine more cities than Dunedin.

\section{Sun}
To generate shadows over the representation given of Dunedin the sun's position has to be calculated accurately using the current time and geographical position.


\subsection{Calculating the Position of the Sun}
To calculate the position of the sun code from the RedShift project\cite{redshift} was used to ensure that the code had been previously tested. Code from other projects were examined, such as the solar positioning libraries for Java\cite{javasunlib} however the algorithms used in this library, the PSA\cite{psa} and SPA\cite{spa} algorithms, have the unfortunate downside that they do not work for areas in the Southern Hemisphere and modifying the algorithms used in their papers are outside the scope of the project.

The code modified from the RedShift library are the solar.c and solar.h files, which are taken from javascript code by U.S. Department of Commerce, National Oceanic & Atmospheric Administration\cite{usnoaa} and is based on equations from Astronomical Algorithms\cite{astronomicalalgorithms}. Using RedShift's implementation of the solar position calculations ported easily into the Java programming language and the results from the version used in the project are very similar to the results from RedShift.

Java automatically handles daylight saving time in its Time class

\subsection{Calculating the Sunrise and Sunset}
Calculations of the sunset and sunrise times taken from \cite{sunrise} 
\subsection{Sun Accuracy}
\begin{figure}
\caption{Device used to accurately calculate the position of the sun}
\label{sun-contraption}
\end{figure}

\begin{table}
\begin{tabular}{ | l | l | l | l  | 1 |}
\hline
Date Time & Sun Azimuth Website & Sun Azimuth Project & Sun Elevation Website & Sun Elevation Project\\ \hline
09:30 January 1st 2011 & 87.94462 & 87.9465 & 35.06 & 35.039\\ \hline
12:00 April 7th 2011 & 12.54622 & 12.5412 & 36.77 & 36.74896\\ \hline
15:19 October 4th & 321.1353 & 321.12823 & 41.72 & 41.698387\\ \hline
\end{tabular}
\caption{Calculated position of the sun using data scraped from satellite-caculations.com\cite{solarpos}}
\label{websun}
\end{table}


The accuracy of the sun was tested by comparing the results from the algorithms used in the project and by other sun position calculators and by creating a device to calculate the position of the sun at the current time. Using the solar position calculator from satellite-caculations.com\cite{solarpos} the solar altitude and azimuth at 15:19 on October 4th is 321.1353 and 41.72 degrees(including atmospheric refraction). Observing \ref{websun} it can be seen that the results generated by the sun code in the project accurately resembles that generated by other code, even without taking atmospheric refraction into account.

A rudimentary device seen in \ref{sun-contraption} was used to calculate the real physical position of the sun by finding the angle between north and the shadow shadow cast by the device and the length of the shadow created compared to the length of the device. The is made up of a piece of string tied to a weight and hung from above to ensure that the device is pointing straight downwards. Data was taken from this device at three different times on the 5th of October and is presented here in a table:

\begin{table}
\begin{tabular}{ | l | l | l | l | p{5cm}}
\hline
Time & Shadow Length & Shadow Azimuth & Sun Height\\ \hline
09:30 & 12cm & 90\degree & 127.23\degree \\ \hline

\end{tabular}
\caption{Calculated position of the sun using real data}
\label{realsun}
\end{table}

\chapter{Viewer}
\begin{figure}[h]
\centering
\includegraphics[scale=0.4]{viewer.png}
\caption{A screenshot of the viewer looking down at Dunedin}
\end{figure}\note{Good to see the screenshot! :-) Can the brightness/contrast be adjusted? It is very dark on my system.}
The viewer is an interactive three-dimensional simulator of the Sun moving over Dunedin. It allows the user to view shadows cast by the sun over the varying landscape. It exposes the ability to run in two different modes; shadow-mapping mode, where OpenGL shadow maps are used to generate shadows, and aggregator shadowing mode, where the shadow data from the aggregator is used to calculate shadows. This chapter will focus mostly on the OpenGL and shadow mapping side of the viewer.

\section{Drawing the elevation data}
Geographical height data is drawn by the viewer using OpenGL. After the height data has been gathered by the program OpenGL buffer objects are created to store the vertex position,colour, texture coordinates and vector normals. Buffer objects allow sending the data to be drawn directly to the graphics cards local memory where it can be redrawn and updated quickly without unnecessary resending. Due to the large number vertices present in the height data and the static nature of the data using buffers to store the data lowers the number of graphics hardware calls significantly in comparison to using the fixed function pipeline.

\section{Shadows}
Shadows are done on the graphics hardware using shadow maps...
In \ref{viewer} a map overlay taken from Google Maps\cite{gmaps} is drawn onto the scene to show major roads, points of interest and terrain information onto the height data. 
\section{Shadows and Lighting}
Shadows and lighting can be shown in the viewer in shadow mapping mode and aggregator mode. In shadow mapping mode the shadows are drawn onto the Dunedin map using 

\section{Shadow Mapping}

\section{Usage}
The viewer can be run on any computer with a reasonably new graphics processor...
\subsection{Control}
The viewer can be controlled using the \texttt{w},\texttt{a},\texttt{s},and \texttt{d} keys to zoom in and out and mouse drags to rotate the screen...
\section{Future Work}
\chapter{Aggregator}
The aggregator is designed to calculate whether a portion of land is in shadow or not more accurately then using OpenGL methods such as shadow mapping...


\section{Picking the areas to scan}
The overlay image seen in \ref{overlaytexture} came in useful when running the aggregator because it can be used to segregate different sections of Dunedin such as suburbs and water. The aggregator uses this image to ignore x,y positions that fall in the water 

Generating this image was also useful when running the aggregator because the water is already clearly marked on the map and thus areas in the water can be safely ignored to get a speed bonus. 



\section{Algorithms Used}
A modified version of Cleary's algorithm was used to calculate whether a given block of land is in shadow or not... See algorithm~\ref{alg:shadow-calculation} for more information... 



\begin{algorithm}[h]
\caption{Calculate whether a given x,y point on the map is in shadow or not}
\label{alg:shadow-calculation}% and a label for \ref{} commands later in the document
\begin{algorithmic}           % enter the algorithmic environment
\STATE $directionToSun \Leftarrow sun.directionVector$
\STATE $heightAtPoint \Leftarrow map.getHeight(x,y)$
\STATE $tdx \Leftarrow 1 / directionToSun.x$
\STATE $tdy \Leftarrow 1 / directionToSun.y$
\STATE $xPostion \Leftarrow x$
\STATE $yPosition \Leftarrow y$
\WHILE{$xPosition < map.width and yPostion < map.height and xPosition \geq 0 and yPosition \geq$}
	\IF{$hieght at xPostion and yPosition and ABS(MAX(tdx,tdy)) > directionToSun.y\times ABS(MAX(tdx,tdy))$}
		\RETURN{$In shadow$}
	\ENDIF
	\IF{$ABS(tdx) < ABS(tdy)$}
		\STATE $dx \Leftarrow 1 / directionToSun.x$
		\IF{$tdx > 0$}
			\STATE $xPosition \Leftarrow xPostion + 1$	
		\ELSE
			\STATE $xPosition \Leftarrow xPostion - 1$	
		\ENDIF
		\STATE $tdx \Leftarrow tdx + dx$
	\ELSE
		\STATE $dx \Leftarrow 1 / directionToSun.y$
		\IF{$tdx > 0$}
			\STATE $yPosition \Leftarrow yPostion + 1$	
		\ELSE
			\STATE $yPosition \Leftarrow yPostion - 1$	
		\ENDIF
		\STATE $tdx \Leftarrow tdy + dy$		
	\ENDIF
\ENDWHILE
\RETURN{$Not in shadow$}
\end{algorithmic}
\end{algorithm}

\section{Optimisations}
The aggregator can run faster by checking for shadows at the edges of an area of land. If there is no shadow present at any of the edges and the area is reasonably flat then it is safe to assume that none of the points within that region will be in shadow. The aggregator uses a square area of 10 points which it scans around the outside edge of for shadows, if no shadow is found then all of the points within the square are set to be not in shadow.


The optimised code ran approximately x faster on a 1.9GHz AMD Dual Core Turion processor. It was also run on a 2.8GHz Intel Core i7 920 processor. The tests were performed by running the optimised and unoptimised versions of the aggregator 1000 times between the times of 08:00 and 18:00 on the 1st of October 2011. 

10 hours so 100 tests an hour so a test every 0.6 minutes
\subsection{Speed-}

\subsection{Different Forms}
Sections of land that stand behind large hills are likely to all be in shadow
\subsection{Other Methods}
The code does not necessarily need to be optimised to speed it up. Now that multi-core processors are becoming more common on modern day computers threading the aggregator code to take advantage of more than one processor and the way the testing for shadows is implemented is easily threadable by spawning a thread for every block in the array that needs to be processed.
Implementing this could even be programmed in massively multi-threading languages such as OpenCL 

\note{Good. Well expressed, too. Perhaps mention that there are more general forms of this optimisation strategy, but that there will be a cross-over point between the efficiency gained by not computing shadow rays against the extra effort in running the optimisation algorithm.}
\section{Data Gathered}
By running the aggregator for the whole year it was seen that suburb x managed to receive the highest amount of sun...
\section{Future work}
\chapter{Conclusion}
In the end the project was able to do x well and didn't do y as well as expected.
\bibliographystyle{abbrv}
\bibliography{480}

\end{document}
